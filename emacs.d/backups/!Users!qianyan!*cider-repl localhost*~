; CIDER 0.9.1 (Java 1.8.0_45, Clojure 1.6.0, nREPL 0.2.6)
WARNING: CIDER requires nREPL 0.2.7 (or newer) to work properly
user> (println [1, 2])
[1 2]
nil
user> 
user> (defn pascal [n]
  (let [newrow (fn newrow [lst ret]
                   (if lst
                       (recur (rest lst)
                              (conj ret (+ (first lst) (or (second lst) 0))))
                       ret))
        genrow (fn genrow [n lst]
                   (when (< 0 n)
                     (do (println lst)
                         (recur (dec n) (conj (newrow lst []) 1)))))]
    (genrow n [1])))
(pascal 4)
#'user/pascal[1]
NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)
user> (pascal 4)
[1]
NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)
user> (defn pascal [n]
  (let [newrow (fn newrow [lst ret]
                   (if lst
                       (recur (rest lst)
                              (conj ret (+ (first lst) (or (second lst) 0))))
                       ret))
        genrow (fn genrow [n lst]
                   (when (< 0 n)
                     (do (println lst)
                         (recur (dec n) (conj (newrow lst []) 1)))))]
    (genrow n [1])))
(pascal 4)
#'user/pascal[1]
NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)
user> (defn nextrow [row]
  (vec (concat [1] (map #(apply + %) (partition 2 1 row)) [1] )))
 
(defn pascal [n]
  (assert (and (integer? n) (pos? n)))
  (let [triangle (take n (iterate nextrow [1]))]
    (doseq [row triangle]
      (println row))))
#'user/nextrow
#'user/pascal
user> (pascal 4)
[1]
[1 1]
[1 2 1]
[1 3 3 1]
nil
user> (defn nextrow [row]
  (vec (concat [1] (map #(apply + %) (partition 2 1 row)) [1] )))
 
(defn pascal [n]
  (assert (and (integer? n) (pos? n)))
  (let [triangle (take n (iterate nextrow [1]))]
    (doseq [row triangle]
      (println (apply str row)))))
#'user/nextrow
#'user/pascal
user> (pascal 4)
1
11
121
1331
nil
user> (defn nextrow [row]
  (vec (concat [1] (map #(apply + %) (partition 2 1 row)) [1] )))
 
(defn pascal [n]
  (assert (and (integer? n) (pos? n)))
  (let [triangle (take n (iterate nextrow [1]))]
    (doseq [row triangle]
      (println (clojure.string/join " " row)))))